# AbstractVoice: Complete AI Integration Guide

## OVERVIEW FOR AI SYSTEMS

AbstractVoice is a professional-grade Python library for voice interactions with AI systems. This document provides comprehensive guidance for AI assistants to effectively integrate and leverage AbstractVoice's capabilities.

## CORE CAPABILITIES

### 1. HIGH-QUALITY TEXT-TO-SPEECH (TTS)
- **Best Model**: VITS (requires espeak-ng) - Natural prosody, human-like intonation
- **Default Model**: fast_pitch (pure Python) - Good quality, works everywhere
- **Alternative**: glow-tts (pure Python) - Similar to fast_pitch
- **Speed Control**: Pitch-preserving speed adjustment (0.5x-2.0x using librosa)
- **Immediate Pause/Resume**: Professional-grade audio control with <20ms response time
- **Long Text Handling**: Automatic sentence segmentation and chunking

### 2. SPEECH-TO-TEXT (STT) 
- **Engine**: OpenAI Whisper (tiny/base/small/medium/large models)
- **Voice Activity Detection**: WebRTC VAD for efficient speech detection
- **Interrupt Handling**: Automatic TTS interruption when user speaks
- **Multiple Modes**: full, wait, stop, ptt (push-to-talk)

### 3. CROSS-PLATFORM COMPATIBILITY
- **Platforms**: macOS, Linux, Windows
- **Dependencies**: Pure Python core, optional espeak-ng for best quality
- **Installation**: Simple pip install, automatic fallbacks

## INSTALLATION COMMANDS FOR AI SYSTEMS

```bash
# Basic installation (English only)
pip install abstractvoice

# Language-specific installation
pip install "abstractvoice[fr]"    # French
pip install "abstractvoice[es]"    # Spanish
pip install "abstractvoice[de]"    # German
pip install "abstractvoice[it]"    # Italian
pip install "abstractvoice[ru]"    # Russian

# Multiple languages
pip install "abstractvoice[fr,es,de,it,ru]"

# All languages (recommended for international AI systems)
pip install "abstractvoice[multilingual]"

# With development dependencies
pip install "abstractvoice[dev,multilingual]"

# From source
git clone https://github.com/lpalbou/abstractvoice.git
cd abstractvoice
pip install -e ".[multilingual]"
```

## ESSENTIAL PROGRAMMATIC USAGE PATTERNS

### 1. BASIC VOICE MANAGER SETUP

#### English (Traditional)
```python
from abstractvoice import VoiceManager

# Initialize with best quality (requires espeak-ng, auto-fallback to fast_pitch)
vm = VoiceManager(
    tts_model="tts_models/en/ljspeech/vits",  # Best quality
    whisper_model="tiny",  # Fast, good for most use cases
    debug_mode=False
)

# Default: Works everywhere (recommended for production)
vm = VoiceManager(
    tts_model="tts_models/en/ljspeech/fast_pitch",  # Default
    whisper_model="tiny"
)

# Simple initialization (uses fast_pitch by default)
vm = VoiceManager()
```

#### Multilingual Setup (Recommended for International AI Systems)
```python
from abstractvoice import VoiceManager

# Language-specific initialization
vm_en = VoiceManager(language='en')     # English (VITS/FastPitch)
vm_fr = VoiceManager(language='fr')     # French (XTTS-v2)
vm_es = VoiceManager(language='es')     # Spanish (XTTS-v2)
vm_de = VoiceManager(language='de')     # German (XTTS-v2)
vm_it = VoiceManager(language='it')     # Italian (XTTS-v2)
vm_ru = VoiceManager(language='ru')     # Russian (XTTS-v2)

# Multilingual instance with dynamic language switching
vm_multi = VoiceManager(language='multilingual')

# Convenience functions for cleaner code
from abstractvoice import (
    VoiceManagerEnglish,
    VoiceManagerFrench,
    VoiceManagerSpanish,
    VoiceManagerGerman,
    VoiceManagerItalian,
    VoiceManagerRussian,
    VoiceManagerMultilingual
)

vm_fr = VoiceManagerFrench()
vm_es = VoiceManagerSpanish()
vm_multi = VoiceManagerMultilingual()
```

### 2. TEXT-TO-SPEECH OPERATIONS

#### Basic Speech Synthesis
```python
# English
vm_en = VoiceManager(language='en')
success = vm_en.speak("Hello, I am your AI assistant!")

# Multilingual examples
vm_fr = VoiceManager(language='fr')
vm_fr.speak("Bonjour! Je suis votre assistant IA.")

vm_es = VoiceManager(language='es')
vm_es.speak("¡Hola! Soy tu asistente de IA.")

vm_de = VoiceManager(language='de')
vm_de.speak("Hallo! Ich bin Ihr KI-Assistent.")

vm_it = VoiceManager(language='it')
vm_it.speak("Ciao! Sono il tuo assistente IA.")

vm_ru = VoiceManager(language='ru')
vm_ru.speak("Привет! Я ваш ИИ-помощник.")
```

#### Dynamic Language Switching
```python
# Single instance, multiple languages
vm = VoiceManager(language='multilingual')

# Speak in different languages
vm.speak("Hello, welcome!", language='en')
vm.speak("Bonjour, bienvenue!", language='fr')
vm.speak("¡Hola, bienvenido!", language='es')
vm.speak("Hallo, willkommen!", language='de')
vm.speak("Ciao, benvenuto!", language='it')
vm.speak("Привет, добро пожаловать!", language='ru')

# Change default language
vm.set_language('fr')
vm.speak("Maintenant je parle français par défaut.")
```

#### Speed Control (Works with All Languages)
```python
# Speed control (preserves pitch)
vm_fr.speak("Vitesse normale", speed=1.0)
vm_fr.speak("Vitesse rapide", speed=1.5)
vm_fr.speak("Vitesse lente", speed=0.7)

# With completion callback
def on_speech_done():
    print("Speech completed")

vm_es.speak("Texto con callback", callback=on_speech_done)

# Check if currently speaking
if vm.is_speaking():
    print("TTS is active")
```

### 3. PROFESSIONAL PAUSE/RESUME CONTROL
```python
# Immediate pause (takes effect in ~20ms)
if vm.pause_speaking():
    print("Successfully paused")
else:
    print("Nothing to pause")

# Resume from exact position
if vm.resume_speaking():
    print("Successfully resumed")
else:
    print("Nothing to resume")

# Check pause state
if vm.is_paused():
    print("Currently paused")

# Stop completely
vm.stop_speaking()
```

### 4. DYNAMIC MODEL AND LANGUAGE SWITCHING
```python
# Change language at runtime
vm = VoiceManager(language='en')
vm.speak("Starting in English")

vm.set_language('fr')
vm.speak("Maintenant en français")

vm.set_language('es')
vm.speak("Ahora en español")

# Get language information
info = vm.get_language_info()
print(f"Current: {info['name']} ({info['code']})")
print(f"Model: {info['model']}")
print(f"Available models: {list(info['available_models'].keys())}")

# List all supported languages
supported = vm.get_supported_languages()
print(f"Supported languages: {supported}")

# Change TTS model at runtime (for English)
vm_en = VoiceManager(language='en')
vm_en.set_tts_model("tts_models/en/ljspeech/vits")  # Best quality (needs espeak-ng)
vm_en.set_tts_model("tts_models/en/ljspeech/fast_pitch")  # Default (works everywhere)
vm_en.set_tts_model("tts_models/en/ljspeech/glow-tts")  # Alternative

# For multilingual, use XTTS-v2
vm_multi = VoiceManager(language='multilingual')
vm_multi.set_tts_model("tts_models/multilingual/multi-dataset/xtts_v2")

# Change Whisper model (affects all languages)
vm.set_whisper("base")  # Better accuracy
vm.set_whisper("tiny")  # Faster processing
current_model = vm.get_whisper()  # Get current model name

# VAD (Voice Activity Detection) sensitivity
vm.change_vad_aggressiveness(2)  # 0-3, higher = more sensitive

# Adjust global speed
vm.set_speed(1.2)  # 20% faster
current_speed = vm.get_speed()
```

### 5. SPEECH-TO-TEXT INTEGRATION
```python
def handle_user_speech(transcribed_text):
    """Process user's spoken input"""
    print(f"User said: {transcribed_text}")
    # Replace with your AI system processing
    response = f"I understand you said: {transcribed_text}"
    vm.speak(response)

def handle_stop_command():
    """Handle when user says 'stop'"""
    print("User requested stop")
    vm.stop_speaking()

# Start listening
vm.listen(
    on_transcription=handle_user_speech,
    on_stop=handle_stop_command
)

# Check listening state
if vm.is_listening():
    print("Actively listening")

# Stop listening
vm.stop_listening()
```

### 6. VOICE MODES FOR DIFFERENT INTERACTIONS
```python
# Full mode: Continuous listening, can interrupt TTS
vm.set_voice_mode("full")

# Wait mode: Listen only when TTS is not playing
vm.set_voice_mode("wait")

# Stop mode: Stop TTS when user speaks
vm.set_voice_mode("stop")

# Push-to-talk mode: Manual control
vm.set_voice_mode("ptt")
```

## ADVANCED INTEGRATION PATTERNS

### 1. MULTILINGUAL AI ASSISTANT
```python
class InternationalAIAssistant:
    def __init__(self):
        # Pre-load voice managers for performance
        self.voices = {
            'en': VoiceManager(language='en'),
            'fr': VoiceManager(language='fr'),
            'es': VoiceManager(language='es'),
            'de': VoiceManager(language='de'),
            'it': VoiceManager(language='it'),
            'ru': VoiceManager(language='ru')
        }
        self.current_language = 'en'

    def set_language(self, language):
        """Switch AI assistant language"""
        if language in self.voices:
            self.current_language = language
            return True
        return False

    def speak(self, text, language=None):
        """Speak in specified or current language"""
        lang = language or self.current_language
        if lang in self.voices:
            self.voices[lang].speak(text)

    def get_greeting(self):
        """Get localized greeting"""
        greetings = {
            'en': "Hello! I'm your AI assistant. How can I help you?",
            'fr': "Bonjour! Je suis votre assistant IA. Comment puis-je vous aider?",
            'es': "¡Hola! Soy tu asistente de IA. ¿Cómo puedo ayudarte?",
            'de': "Hallo! Ich bin Ihr KI-Assistent. Wie kann ich Ihnen helfen?",
            'it': "Ciao! Sono il tuo assistente IA. Come posso aiutarti?",
            'ru': "Привет! Я ваш ИИ-помощник. Как я могу вам помочь?"
        }
        message = greetings.get(self.current_language, greetings['en'])
        self.speak(message)

    def demonstrate_languages(self):
        """Demonstrate all supported languages"""
        for lang in self.voices.keys():
            self.set_language(lang)
            self.get_greeting()
            time.sleep(3)  # Pause between languages

# Usage
assistant = InternationalAIAssistant()
assistant.set_language('fr')
assistant.speak("Bienvenue dans notre assistant multilingue!")
```

### 2. STREAMING AI RESPONSES WITH VOICE
```python
def stream_ai_response_with_voice(user_input):
    """Stream AI response with immediate TTS feedback"""
    
    # Replace with your AI streaming generator
    def mock_ai_generator(text):
        sentences = [
            f"Processing your input: {text}.",
            "This is the first part of my response.",
            "Here's additional information.",
            "Thank you for your question!"
        ]
        for sentence in sentences:
            yield sentence
    
    # Start generating response
    response_chunks = mock_ai_generator(user_input)
    
    full_response = ""
    current_sentence = ""
    
    for chunk in response_chunks:
        full_response += chunk
        current_sentence += chunk
        
        # Speak complete sentences immediately
        if chunk.endswith(('.', '!', '?')):
            vm.speak(current_sentence.strip())
            current_sentence = ""
    
    # Speak any remaining text
    if current_sentence.strip():
        vm.speak(current_sentence.strip())
    
    return full_response
```

### 2. INTERRUPT-SAFE AI CONVERSATIONS
```python
class VoiceAIConversation:
    def __init__(self):
        self.vm = VoiceManager()
        self.conversation_active = False
    
    def start_conversation(self):
        """Start voice conversation with interrupt handling"""
        self.conversation_active = True
        
        def on_user_input(text):
            if not self.conversation_active:
                return
            
            # Stop any current AI speech
            self.vm.stop_speaking()
            
            # Process user input
            ai_response = self.process_with_ai(text)
            
            # Speak response if conversation still active
            if self.conversation_active:
                self.vm.speak(ai_response)
        
        def on_stop():
            self.conversation_active = False
            self.vm.speak("Goodbye!")
        
        self.vm.listen(
            on_transcription=on_user_input,
            on_stop=on_stop
        )
    
    def process_with_ai(self, user_text):
        """Replace with your AI processing logic"""
        # Example responses - replace with your AI system
        responses = [
            f"I understand you said: {user_text}",
            "That's interesting! Tell me more.",
            "I'm processing that information.",
            "How can I help you further?"
        ]
        import random
        return random.choice(responses)
```

### 3. MULTI-THREADED VOICE CONTROL
```python
import threading
import time

class ThreadSafeVoiceController:
    def __init__(self):
        self.vm = VoiceManager()
        self.speech_queue = []
        self.queue_lock = threading.Lock()
        self.worker_thread = None
        self.running = False
    
    def start_worker(self):
        """Start background speech worker"""
        self.running = True
        self.worker_thread = threading.Thread(target=self._speech_worker)
        self.worker_thread.start()
    
    def _speech_worker(self):
        """Background worker for queued speech"""
        while self.running:
            with self.queue_lock:
                if self.speech_queue and not self.vm.is_speaking():
                    text, speed = self.speech_queue.pop(0)
                    self.vm.speak(text, speed=speed)
            time.sleep(0.1)
    
    def queue_speech(self, text, speed=1.0):
        """Thread-safe speech queueing"""
        with self.queue_lock:
            self.speech_queue.append((text, speed))
    
    def emergency_stop(self):
        """Immediate stop from any thread"""
        with self.queue_lock:
            self.speech_queue.clear()
        self.vm.stop_speaking()
```

## ERROR HANDLING AND FALLBACKS

### 1. ROBUST MODEL INITIALIZATION
```python
def create_robust_voice_manager():
    """Create VoiceManager with automatic fallbacks"""
    
    # Try best quality first (requires espeak-ng)
    try:
        vm = VoiceManager(tts_model="tts_models/en/ljspeech/vits")
        print("✅ Using VITS model (best quality)")
        return vm
    except Exception as e:
        print(f"⚠️ VITS failed (espeak-ng missing?): {e}")
    
    # Fallback to default model (works everywhere)
    try:
        vm = VoiceManager(tts_model="tts_models/en/ljspeech/fast_pitch")
        print("✅ Using fast_pitch model (default quality)")
        return vm
    except Exception as e:
        print(f"❌ All TTS models failed: {e}")
        return None

# Usage
vm = create_robust_voice_manager()
if vm is None:
    print("Voice functionality unavailable")
```

### 2. GRACEFUL ERROR HANDLING
```python
def safe_voice_operation(vm, operation, *args, **kwargs):
    """Safely execute voice operations with error handling"""
    try:
        if operation == "speak":
            return vm.speak(*args, **kwargs)
        elif operation == "pause":
            return vm.pause_speaking()
        elif operation == "resume":
            return vm.resume_speaking()
        elif operation == "stop":
            return vm.stop_speaking()
        else:
            return False
    except Exception as e:
        print(f"Voice operation failed: {e}")
        return False

# Usage
success = safe_voice_operation(vm, "speak", "Hello world")
if not success:
    print("Speech failed, using text fallback")
```

## PERFORMANCE OPTIMIZATION

### 1. EFFICIENT LONG TEXT HANDLING
```python
def optimize_long_text_speech(vm, long_text):
    """Optimize speech for very long texts"""
    
    # AbstractVoice automatically handles sentence segmentation
    # But you can pre-process for better results
    
    # Split into paragraphs for natural pauses
    paragraphs = long_text.split('\n\n')
    
    for i, paragraph in enumerate(paragraphs):
        if not paragraph.strip():
            continue
        
        # Add natural pause between paragraphs
        if i > 0:
            time.sleep(0.5)
        
        # Speak paragraph (AbstractVoice handles sentence chunking)
        vm.speak(paragraph.strip())
        
        # Check if user interrupted
        if not vm.is_speaking():
            break  # User stopped playback
```

### 2. MEMORY-EFFICIENT STREAMING
```python
def memory_efficient_speech_stream(vm, text_generator):
    """Stream speech without loading all text into memory"""
    
    sentence_buffer = ""
    
    for text_chunk in text_generator:
        sentence_buffer += text_chunk
        
        # Speak complete sentences as they arrive
        while '.' in sentence_buffer or '!' in sentence_buffer or '?' in sentence_buffer:
            # Find sentence boundary
            for punct in ['.', '!', '?']:
                if punct in sentence_buffer:
                    idx = sentence_buffer.find(punct)
                    sentence = sentence_buffer[:idx+1].strip()
                    sentence_buffer = sentence_buffer[idx+1:].strip()
                    
                    if sentence:
                        vm.speak(sentence)
                    break
    
    # Speak any remaining text
    if sentence_buffer.strip():
        vm.speak(sentence_buffer.strip())
```

## INTEGRATION WITH POPULAR AI FRAMEWORKS

### 1. OPENAI API INTEGRATION
```python
import openai

def voice_chat_with_openai(vm, api_key):
    """Voice chat using OpenAI API"""
    
    openai.api_key = api_key
    conversation_history = []
    
    def process_user_speech(user_text):
        conversation_history.append({"role": "user", "content": user_text})
        
        # Get AI response
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=conversation_history
        )
        
        ai_text = response.choices[0].message.content
        conversation_history.append({"role": "assistant", "content": ai_text})
        
        # Speak AI response
        vm.speak(ai_text)
    
    vm.listen(on_transcription=process_user_speech)
```

### 2. LANGCHAIN INTEGRATION
```python
from langchain.llms import OpenAI
from langchain.chains import ConversationChain
from langchain.memory import ConversationBufferMemory

def voice_langchain_chat(vm, openai_api_key):
    """Voice chat using LangChain"""
    
    llm = OpenAI(openai_api_key=openai_api_key)
    memory = ConversationBufferMemory()
    conversation = ConversationChain(llm=llm, memory=memory)
    
    def handle_voice_input(user_text):
        # Process with LangChain
        ai_response = conversation.predict(input=user_text)
        
        # Speak response
        vm.speak(ai_response)
    
    vm.listen(on_transcription=handle_voice_input)
```

## DEPLOYMENT CONSIDERATIONS

### 1. PRODUCTION DEPLOYMENT
```python
# Production-ready initialization
def create_production_voice_manager():
    """Production-ready VoiceManager setup"""
    
    import logging
    logging.basicConfig(level=logging.WARNING)  # Reduce noise
    
    # Use reliable model for production
    vm = VoiceManager(
        tts_model="tts_models/en/ljspeech/fast_pitch",  # Reliable
        whisper_model="tiny",  # Fast, low resource usage
        debug_mode=False  # Disable debug output
    )
    
    return vm
```

### 2. RESOURCE CLEANUP
```python
def cleanup_voice_resources(vm):
    """Proper cleanup for production environments"""
    try:
        vm.stop_speaking()
        vm.stop_listening()
        vm.cleanup()
        print("✅ Voice resources cleaned up")
    except Exception as e:
        print(f"⚠️ Cleanup warning: {e}")
```

## TROUBLESHOOTING FOR AI SYSTEMS

### Common Issues and Solutions:

1. **TTS Model Loading Fails**
   - Solution: Use fallback model `"tts_models/en/ljspeech/fast_pitch"`
   - Check: espeak-ng installation for VITS model

2. **Audio Device Issues**
   - Solution: Check `sounddevice.query_devices()` for available devices
   - Fallback: Use text-only mode if audio unavailable

3. **Pause/Resume Not Working**
   - Check: Use `is_speaking()` before pause operations
   - Ensure: Call `pause_speaking()` not during synthesis startup

4. **Memory Issues with Long Text**
   - Solution: AbstractVoice automatically chunks text
   - Optimization: Pre-split very long texts into paragraphs

5. **Cross-Platform Compatibility**
   - Windows: May need Visual C++ redistributables
   - macOS: May show audio permission dialogs
   - Linux: Ensure ALSA/PulseAudio is available

## COMPLETE WORKING EXAMPLE

```python
#!/usr/bin/env python3
"""Complete AbstractVoice multilingual integration example for AI systems"""

from abstractvoice import VoiceManager, VoiceManagerMultilingual
import time
import threading

class MultilingualAIVoiceAssistant:
    def __init__(self, default_language='en'):
        self.default_language = default_language

        # Initialize with automatic fallback and multilingual support
        try:
            if default_language == 'en':
                self.vm = VoiceManager(
                    tts_model="tts_models/en/ljspeech/vits",
                    whisper_model="tiny"
                )
                print("✅ Voice system ready (English VITS model)")
            else:
                self.vm = VoiceManager(
                    language=default_language,
                    whisper_model="tiny"
                )
                language_name = self.vm.LANGUAGE_NAMES.get(default_language, default_language)
                print(f"✅ Voice system ready ({language_name} XTTS-v2 model)")
        except Exception as e:
            print(f"⚠️ Primary model failed: {e}")
            self.vm = VoiceManager(
                tts_model="tts_models/en/ljspeech/fast_pitch",
                whisper_model="tiny"
            )
            print("✅ Voice system ready (fallback model)")

        self.conversation_active = False

    def set_language(self, language):
        """Change assistant language"""
        if self.vm.set_language(language):
            self.default_language = language
            lang_name = self.vm.LANGUAGE_NAMES.get(language, language)
            print(f"🌍 Language changed to: {lang_name}")
            return True
        return False
    
    def start_conversation(self):
        """Start voice conversation"""
        self.conversation_active = True
        
        # Welcome message
        self.vm.speak("Hello! I'm your AI assistant. How can I help you today?")
        
        # Start listening
        self.vm.listen(
            on_transcription=self.handle_user_input,
            on_stop=self.handle_stop
        )
        
        print("🎤 Listening... (say 'stop' to exit)")
    
    def handle_user_input(self, user_text):
        """Process user speech input"""
        if not self.conversation_active:
            return
        
        print(f"👤 User: {user_text}")
        
        # Stop any current speech
        self.vm.stop_speaking()
        
        # Process with AI (placeholder)
        ai_response = self.generate_ai_response(user_text)
        
        # Speak response
        if self.conversation_active:
            print(f"🤖 AI: {ai_response}")
            self.vm.speak(ai_response)
    
    def generate_ai_response(self, user_text):
        """Generate AI response (replace with your AI system)"""
        # Placeholder - integrate with your AI system here
        responses = [
            f"I understand you said: {user_text}",
            "That's interesting! Tell me more.",
            "I'm processing that information.",
            "How can I help you further?"
        ]
        import random
        return random.choice(responses)
    
    def handle_stop(self):
        """Handle stop command"""
        self.conversation_active = False
        self.vm.speak("Goodbye! Have a great day!")
        time.sleep(2)  # Let goodbye message finish
    
    def pause_resume_demo(self):
        """Demonstrate pause/resume functionality"""
        print("🎵 Pause/Resume Demo")
        
        # Start long speech
        long_text = """
        This is a demonstration of AbstractVoice's immediate pause and resume functionality. 
        The system can pause speech within 20 milliseconds and resume from the exact position. 
        This creates a professional user experience with no repetition or gaps in audio playback.
        """
        
        self.vm.speak(long_text)
        
        # Pause after 3 seconds
        time.sleep(3)
        print("⏸️ Pausing...")
        self.vm.pause_speaking()
        
        # Resume after 2 seconds
        time.sleep(2)
        print("▶️ Resuming...")
        self.vm.resume_speaking()
    
    def cleanup(self):
        """Clean up resources"""
        self.conversation_active = False
        self.vm.cleanup()

# Example usage
if __name__ == "__main__":
    assistant = AIVoiceAssistant()
    
    try:
        # Demo pause/resume
        assistant.pause_resume_demo()
        time.sleep(10)  # Let demo finish
        
        # Start conversation
        assistant.start_conversation()
        
        # Keep running until interrupted
        while assistant.conversation_active:
            time.sleep(0.1)
    
    except KeyboardInterrupt:
        print("\n🛑 Interrupted by user")
    
    finally:
        assistant.cleanup()
        print("✅ Cleanup complete")
```

This comprehensive guide provides AI systems with all necessary information to effectively integrate and leverage AbstractVoice's professional voice interaction capabilities.
